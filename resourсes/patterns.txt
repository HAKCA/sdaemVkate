№1 Что такое «шаблон проектирования»? |
Проверенное и готовое к использованию логическое решение, которое может быть
реализовано по-разному в разных языках программирования.
Плюсы:
• снижение сложности разработки за счет готовых абстракций;
• облегчение коммуникации между разработчиками.
Минусы:
• слепое следование некоторому шаблону может привести к усложнению программы;
• желание попробовать некоторый шаблон в деле без особых на то оснований.

№2 Назовите основные характеристики шаблонов |
• имя – все шаблоны имеют уникальное имя, служащее для их идентификации;
• назначение данного шаблона;
• задача, которую шаблон позволяет решить;
• способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где
этот шаблон был найден;
• участники – сущности, принимающие участие в решении задачи;
• следствия от использования шаблона как результат действий, выполняемых в
шаблоне;
• реализация – возможный вариант реализации шаблона.

№3 Назовите три основные группы паттернов |
Порождающие – отвечают за удобное и безопасное создание новых объектов или даже
целых семейств объектов без внесения в программу лишних зависимостей.
Структурные – отвечают за построение удобных в поддержке иерархий классов.
Поведенческие – заботятся об эффективной коммуникации между объектами.
Основные – основные строительные блоки, используемые для построения других
шаблонов. Например, интерфейс.

№4 Расскажите про паттерн «Одиночка» (Singleton) |
Порождающий паттерн проектирования, который гарантирует, что у класса есть только один
экземпляр, и предоставляет к нему глобальную точку доступа.
Конструктор помечается как private, а для создания нового объекта Singleton использует
специальный метод getInstance(). Он либо создает объект, либо отдаёе существующий
объект, если он уже был создан.
Плюсы:
• можно не создавать множество объектов для ресурсоемких задач, а пользоваться
одним.
Минусы:
• нарушает принцип единой ответственности, так как его могут использовать множество
объектов.

№5 Почему паттерн «Одиночка» (Singleton) считается антипаттерном? |
• нельзя тестировать с помощью mock, но можно использовать powerMock;
• нарушает принцип единой ответственности;
• нарушает Open/Close принцип, его нельзя расширить

№6 Можно ли синхронизировать паттерн «Одиночка» без synchronized у метода? |
1. Можно сделать его Enum (eager). Это статический final класс с константами. JVM
загружает final и static классы на этапе компиляции, а значит несколько потоков не
могут создать несколько инстансов.
2. C помощью double checked locking (lazy).

№7 Расскажите про паттерн «Строитель» (Builder) |
Порождающий паттерн, который позволяет создавать сложные объекты пошагово.
Строитель дает возможность использовать один и тот же код для получения разных
представлений одного объекта. Паттерн предлагает вынести конструирование объекта за пределы 
его собственного класса, поручив это дело отдельным объектам, называемым строителями.
Процесс конструирования объекта разбит на отдельные шаги (например, построитьСтены,
вставитьДвери). Чтобы создать объект, нужно поочередно вызывать методы строителя.
Можно пойти дальше и выделить вызовы методов строителя в отдельный класс,
называемый Директором. В этом случае Директор будет задавать порядок шагов
строительства, а строитель – выполнять их.
Плюсы:
• позволяет использовать один и тот же код для создания различных объектов;
• изолирует сложный код сборки объектов от его основной бизнес-логики.
Минусы:
• усложняет код программы из-за введения дополнительных классов.

№8 Расскажите про паттерн «Фабричный метод» (Factory Method) |
Порождающий шаблон проектирования, в котором подклассы имплементируют общий
интерфейс с методом для создания объектов. Переопределенный метод в каждом
наследнике возвращает нужный вариант объекта.
Объекты все равно будут создаваться при помощи new, но делать это будет фабричный
метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы
изменить тип создаваемого продукта.
Чтобы эта система заработала, все возвращаемые объекты должны иметь общий
интерфейс. Подклассы смогут производить объекты различных классов, следующих одному
и тому же интерфейсу.
Плюсы:
• выделяет код производства объектов в одно место, упрощая поддержку кода;
• реализует принцип открытости/закрытости.
Минусы:
• может привести к созданию больших параллельных иерархий классов, так как для
каждого класса продукта надо создать свой подкласс создателя.
Пример: SessionFactory в Hibernate.

№9 Расскажите про паттерн «Абстрактная фабрика» (Abstract Factory) |
Порождающий паттерн проектирования, который представляет собой интерфейс для
создания других классов, не привязываясь к конкретным классам создаваемых объектов.
Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов,
составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все
диваны реализуют интерфейс Диван и так далее. Далее создается абстрактная фабрика – общий интерфейс, 
который содержит фабричные методы создания всех продуктов семейства. Эти операции должны возвращать 
абстрактные типы продуктов, представленные интерфейсами, которые выделили ранее – Кресла, Диваны и Столики.
Плюсы:
• гарантированно будет создаваться тип одного семейства.
Минусы:
• усложняет код программы из-за введения множества дополнительных классов.

№10 Расскажите про паттерн «Прототип» (Prototype) |
Порождающий паттерн проектирования, который позволяет копировать объекты, не
вдаваясь в подробности их реализации. 
Паттерн поручает создание копий самим копируемым объектам. Он вводит общий
интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация
этого метода в разных классах очень схожа. Метод создает новый объект текущего класса и
копирует в него значения всех полей собственного объекта.
Плюсы:
• позволяет клонировать объекты, не привязываясь к их конкретным классам.
Минусы:
• сложно клонировать составные объекты, имеющие ссылки на другие объекты.

№11 Расскажите про паттерн «Адаптер» (Adapter) |
Структурный паттерн проектирования, который позволяет объектам с несовместимыми
интерфейсами работать вместе.
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в
такой вид, чтобы он стал понятен другому объекту.
При этом адаптер оборачивает один из объектов так, что другой объект даже не знает о
наличии первого.
Плюсы:
• отделяет и скрывает от клиента подробности преобразования различных
интерфейсов.
Минусы:
• усложняет код программы из-за введения дополнительных классов.

№12 Расскажите про паттерн «Декоратор» (Decorator) |
Структурный паттерн проектирования, который позволяет добавлять объектам новую
функциональность, оборачивая их в полезные «обертки».
Целевой объект помещается в другой объект-обертку, который запускает базовое поведение
обернутого объекта, а затем добавляет к результату что-то свое.
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с
каким объектом работать – чистым или обернутым. Можно использовать несколько разных
оберток одновременно – результат будет иметь объединенное поведение всех оберток сразу
Адаптер не меняет состояния объекта, а декоратор может менять.
Плюсы:
• большая гибкость, чем у наследования.
Минусы:
• труднее конфигурировать многократно обернутые объекты.

№13 Расскажите про паттерн «Заместитель» (Proxy) |
Структурный паттерн проектирования, который позволяет подставлять вместо реальных
объектов специальные объекты-заменители, которые перехватывают вызовы к
оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу
Заместитель предлагает создать новый класс-дублер, имеющий тот же интерфейс, что и
оригинальный служебный объект. При получении запроса от клиента объект-заместитель
сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая
выполнялась бы до (или после) вызовов этих же методов в настоящем объекте.
Плюсы:
• позволяет контролировать сервисный объект незаметно для клиента.
Минусы:
• увеличивает время отклика от сервиса.

№14 Расскажите про паттерн «Итератор» (Iterator) |
Поведенческий паттерн проектирования, который дает возможность последовательно
обходить элементы составных объектов, не раскрывая их внутреннего представления.
Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в
отдельный класс.
Детали: создается итератор и интерфейс, который возвращает итератор. В классе, в котором
надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам
итератор делаем там нестатическим вложенным классом, так как он нигде использоваться
больше не будет.

№15 Расскажите про паттерн «Шаблонный метод» (Template Method) |
Поведенческий паттерн проектирования, который пошагово определяет алгоритм и
позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его
структуру в целом.
Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в
отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания
шагов используется абстрактный класс. Общие шаги можно будет описать прямо в
абстрактном классе. Это позволит подклассам переопределять некоторые шаги алгоритма,
оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так
важны.

№16 Расскажите про паттерн «Цепочка обязанностей» (Chain of Responsibility) |
Поведенческий паттерн проектирования, который позволяет передавать запросы
последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он
обработать запрос сам и стоит ли передавать запрос дальше по цепи.
Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным
методом выполнения. Данные запроса, над которым происходит проверка, будут
передаваться в метод как аргументы.
Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь.
Таким образом, при получении запроса обработчик сможет не только сам что-то с ним
сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать,
если проверка в одном из методов не прошла.

№17 Какие паттерны используются в Spring Framework? |
• Singleton – Bean scopes;
• Factory – Bean Factory classes;
• Prototype – Bean scopes;
• Adapter – Spring Web and Spring MVC;
• Proxy – Spring Aspect Oriented Programming support;
• Template Method – JdbcTemplate, HibernateTemplate etc;
• Front Controller – Spring MVC DispatcherServlet;
• DAO – Spring Data Access Object support;
• Dependency Injection.

№18 Какие паттерны используются в Hibernate? |
• Domain Model – объектная модель предметной области, включающая в себя как
поведение, так и данные;
• Data Mapper – слой мапперов (Mappers), который передает данные между объектами
и базой данных, сохраняя их независимыми друг от друга и себя;
• Proxy – применяется для ленивой загрузки;
• Factory – используется в SessionFactory

№19 Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion(высокая сплоченность) |
Low Coupling – части системы, которые изменяются вместе, должны находиться близко друг
к другу.
High Cohesion – если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы
разместить всю функциональность в одном единственном классе. В таком случае связей не
будет вообще, но в этот класс попадет совершенно несвязанная между собой бизнес-логика.
Принцип High Cohesion говорит следующее: части системы, которые изменяются
параллельно, должны иметь как можно меньше зависимостей друг на друга.
Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна,
рассматривать которые имеет смысл только вместе. Их суть: система должна состоять из
слабо связанных классов, которые содержат связанную бизнес-логику. Соблюдение этих
принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их
зоне ответственности.

№20 Расскажите про паттерн Saga |
Сага – это механизм, обеспечивающий согласованность данных в микросервисах без
применения распределенных транзакций.
Для каждой системной команды, которой надо обновлять данные в нескольких сервисах,
создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из
последовательных локальных ACID-транзакций, каждая из которых обновляет данные в
одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие
транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции
выполнились успешно.
Типов транзакций в саге четыре:
• компенсирующая – отменяет изменение, сделанное локальной транзакцией;
• компенсируемая – это транзакция, которую необходимо компенсировать (отменить)
в случае, если последующие транзакции завершаются неудачей;
• поворотная – транзакция, определяющая успешность всей саги: если она
выполняется успешно, то сага гарантированно дойдет до конца;
• повторяемая – идет после поворотной и гарантированно завершается успехом

№21 Расскажите про паттерн Curcuit Breaker ("переключатель цепи", предохранитель) |
Circuit Breaker (переводится как «переключатель цепи») — это паттерн проектирования, 
который используется для обработки ошибок и отказов в распределённых системах на Java. 
Он призван предотвращать появление и распространение ошибок в системе, предоставляя 
более гибкий и контролируемый способ обработки сбоев. 
Принцип работы Circuit Breaker: 
Закрытое состояние (Closed). Когда всё работает нормально, переключатель цепи находится 
в закрытом состоянии. В этом состоянии запросы проходят без вмешательства переключателя. 
Открытое состояние (Open). Если количество ошибок превышает определённый порог, переключатель переходит 
в открытое состояние. В этом состоянии запросы не передаются, а система предполагает, что сервис недоступен. 
Полуоткрытое состояние (Half-Open). После некоторого времени переключатель переходит в полуоткрытое состояние, 
позволяя ограниченное количество запросов проходить. Если большинство запросов проходит успешно, переключатель 
возвращается в закрытое состояние. В противном случае он остаётся открытым.