№1 Что такое ООП? |
Представление программы в виде совокупности объектов, каждый из которых
является экземпляром определенного класса, а классы образуют иерархию наследования

• объектно-ориентированное программирование использует в качестве основных
логических конструктивных элементов объекты, а не алгоритмы;
• каждый объект является экземпляром определенного класса;
• классы образуют иерархии.

№2 Что такое класс? |
Это набор данных ( полей, атрибутов, членов класса) и функций работы с ними
Грубо говоря - шаблон.

№3 Что такое объект? |
Отдельный представитель класса, имеющий конкретное состояние и поведение, опредляемое классом.
То, что мы делаем по шаблону (классу). 

№4 Преимущества ООП |
1) Упрощение разработки ( всё можно использовать много раз в разных местах)
Легко читается, быстро пишется.
2) Структуризация
3) Принципы ( П А Н И )

№5 Недостатки ООП |
1) Потребление памяти
2) Снижение производительности

№6 Инкапсуляция |
Прячем данные от пользователя и воздействуем на них путём методов
Пример: геттеры и сеттеры.
Сами модификаторы доступа уже являются инкапсуляцией

№7 Наследование |
Возможность описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью

№8 Полиморфизм |
Использовать один метод или интерфейс для разных объектов по разному
Переопределение метода – динамический
Статический – когда одно название метода, но разные данные на вход

№9 Абстракция |
Набор каких то методов и характеристик чего либо без конкретной реализации
абстрактные классы и интерфейсы

№10 Ассоциация, агрегация и композиция |
а) Ассоциация – когда объекты ссылаются друг на друга
ассоциация – сам класс имеет не инициализированное поле этого класса. А дальше либо через конструктор, либо через геттеры и сеттеры мы добавляем объект другого класса
б) Агрегация – часть -целое. В котором часть может существовать отдельно от целого. Может являться частью только одного объекта.
в) Композиция подвид агрегации когда часть не может существовать без целого
Вложеннный класс класс который лежит в каком то классе – композиция
Вложенный статический класс – это агрегация

№11 Статическое и динамическое связывание |
Присоединение вызова метода к телу метода называется связыванием.
Раннее статическое связывание - происходит на этапе компиляции, используется не конкретный объект, а информация о его типе. Знает какой метод будет вызван
Позднее динамическое связывание - происходит во время выполнения программы JVM и работает конкретно с объектами. Информация во время компиляции не доступна, 
объекты создаются во время выполнения программы. Не знает какой метод будет вызван.

№12 SOLID принципы важно знать названия и содержимое | 
По заветам солед изначально делаем грамотных код, который в дальнейшем будет проще поддерживать
1. DRY / Don't Repeat Yourself (Не повторяйся): Каждый класс должен иметь только одну зону ответственности
2. OR / Occam's Razor (Бритва Оккама): Классы должны быть открыты для расширения, но закрыты для изменения. (Полиморфизм, интерфейсы)
3. KISS / Keep it Simple Stupid (Делай всё проще): Поведение потомка не должно противоречить поведению родителя
4. YAGNI / You Aren't Gonna Need It (Вам это не понадобится): Не нужно заставлять класс реализовывать интерфейс, который не имеет к нему отношения.
5. BDUF / Big Design Up Front (Масштабное проектирование прежде всего): Абстракции НЕ должны зависеть от деталей. Детали должны зависеть от абстракций. Модули верхнего уровня 
НЕ должны зависеть от модулей нижнего уровня, НО должны зависеть от абстракции.

№13 Дополнительные принципы программирования |
1. Не используй один и тот же код в нескольких местах. Сделай методы.
2. Если код используется единожды, нет смысла для него делать отдельный класс/метод.
3. Делай как можно проще.
4. Добавляй методы и переменные, которые нужны конкретно сейчас.
5. Проектируй думай наперёд
6. Открыто для внедрения новых областей, но закрыто для изменений. 
7. Функции должны выполнять только одно действие, но выполнять его хорошо
8. Разделение команд и запросов (Метод может быть запросом, возвращающим какое-то значение, или командой, но не одновременно тем и другим).

№14 Какая основная идея языка? |
Написано однажды - работает везде
Кроссплатформенность реализовывается через JVM

№15 JVM это? |
Прослойка между операционной системой и java программой, её задача исполнять bite code. Виртуальная машина java

№16 Преимущества Java |
а) объектно-ориентированное
б) проще учиться, эфективнее использвовать
в) выбор многих корпораций – JAVA
г) кроссплатформенность
д) Безопасность
е) автотические управление памятью, плюс мусорщик
ё) многопоточность

№17 Недостатки Java |
а) Низкая производительность. Из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.
б) Платное коммерческое использование

№18 JDK это что |
набор инструментов для разработки приложений
а)компилятор JAVAC или Just in Time компилятор
б) стандартные библиотеки
в) примеры использования методов
г) документация
д) различные утилиты (программы нацеленные на решение конкретных задач)
е) JRE

№19 Что такое JRE? Что в него входит? |
JRE (Java Runtime Environment) – это минимально-необходимая реализация
виртуальной машины для исполнения Java-приложений.
Состоит из JVM, ClassLoader и Library (стандартного набора библиотек и классов Java).

№20 Что такое byte code? |
Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM.
Промежуточный код который создаётся компилятором, а потом с помощью java машины мы его преобразовываем для исполнения программы

№21 ClassLoader |
Обеспечивает загрузку классов Java. Он абстрактен, конкретно загрузку обеспечивают его наследники
Bootstrap (базовый загрузчик) Загружает стандартные классы JDK (Java Development Kit) из архива rt.jar
Extension ClassLoader (з-к расширений) Загружает классы расширений, которые по умолчанию находятся в каталоге
JAR файлы в директории lib/ext из JRE
System ClassLoader (системный з-к) Загружает классы приложения, определённые в переменной среды окружения java.class.path – отвечает за загрузку классов 
в памяти во время выполнения программы

№22 JIT (Just in time compilation) |
компиляция на лету или динамическая компиляция.
Технология увеличения производительности программных систем, использующих
байт-код, путем компиляции байт-кода в машинный код во время работы программы.
В основном отвечает за оптимизацию производительности приложений во время
выполнения.

№23 Виды ссылок |
Сильные – сборщик не удаляет то на что ссылаются сильные ссылки
Мягкие – для кеширования, удаляются когда не хватает памяти
Слабые – для хранения слабых ссылок, которые можно собрать при следующем проходе сборщика мусора
Фантомные – используются для выполнения действий после завершения сборки мусора. (Почитать) Могут быть удалены в любой момент.

№24 Сборщик мусора. |
В Java используется автоматическое управление памятью.
Finalize() сборщик мусора использует автоматически, но можно и самому прописать, но лучше так не делать
Учет ссылок (Reference counting). Суть этого подхода состоит в том, что каждый объект имеет счетчик. 
Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. 
Если значение счетчика равно нулю, объект можно считать мусором.
Если объект не имеет ссылок, он считается мусором.

Трассировка (Tracing), используется в HotSpot (популярная
разновидность JVM).
До объекта можно добраться из корневых точек (GC root).
Если до чего-то добраться нельзя, то это мусор.
Всё, что доступно из «живого» объекта, также является «живым».
Типы корневых точек GC Roots java приложения:
• объекты в статических полях классов
• объекты, доступные из стека потоков
• объекты из JNI (Java Native Interface) ссылок в native
Методах (написанные на другом языке)
• локальные переменные и параметры методов

№25 Виды сборщиков мусора |
Serial (последовательный) — самый простой вариант для приложений с
небольшим объемом данных и не требовательных к задержкам. Редко когда
используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. 
Parallel, Concurrent Mark Sweep (CMS), Garbage-First, Epsilon GC— разработан для случаев, 
когда сборка мусора вообще не нужна. ZGC, Shenandoah GC (рассказать про любой)

№26 final finally finalize |
final - относится к переменной, её нельзя изменить
finally - в try блок, который будет выполнен после всех действий
finalize - метод вызываемый сборщиком перед удалением объекта

№27 Что такое Heap и Stack память в Java? Чем они отличаются? |
Для оптимальной работы приложения JVM делит память:
• на область стека Stack – тут хранятся примитивы и ссылки на объекты
• и область кучи Heap – тут создаются и хранятся объекты
Stack на него выделяется меньше памяти
На heap больше памяти

№28 Какие примитивные типы данных есть в Java? |
1. Целые числа – byte 1, short 2 , int 4 , long 8 (4 типа или 2^2)
2. Вещественные – float 4 , double 8 (числа с плавающей точкой, 2 типа или 2^1)
3. Символьный – char 2 (один тип или 2^0)
4. Логический – boolean  1 в массиве 4 в коде (один тип или 2^0)

№29 Что такое char? |
Беззнаковое целое (2 байта памяти), представляющее собой символ UTF-
16

№30 Классы обёртки |
Аналоги стандартных примитивов, но с большим функционалом.
Нужны для реализации дженериков
Автоупаковка когда из примитива в обёртку
Автораспаковка когда из обёртки в примитив

№31 Что такое явное и неявное приведение типов (иначе называют кастинг)? В каких случаях в java нужно использовать явное приведение? |
Неявное когда программа делает автоматически, явное, когда надо указывать конкретно.
Неявное от меньшего к большему, пример byte to int
Явное от большего к меньшему int to bite
меньше памяти будет есть пример: int a = 5; byte i = (byte)a;

№32 Пулл интов |
Место где содержатся числа
-128 до 127, можно сравнивать ==, а если выходит за рамки, методом Integer

№33 Какие нюансы у строк в Java? |
String – это строка символов.
String – неизменяемый (Immutable), финализированный (final) класс
Переменная ссылочного типа
Как реализована неизменяемость строк? 1) final 2) private 3) нет сеттеров
При конкветенации можем использовать +

№34 Что такое пул строк? |
Пулл строк, создаётся через New, содержит уникальный набор строк
Куча – каждый раз создаёт новую строку
Пулл строк хешируется, находит по хешу нужную ссылку
Когда мы используем оператор new, виртуальная машина создает объект String, но не
хранит его в пуле строк. Мы можем использовать метод intern() для сохранения строки в
пуле строк, или получения ссылки, если такая строка уже находится в пуле

№35 Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать? |
Память забьётся, лучше использовать StringBuffer и StringBuilder

№36 Почему String является популярным ключом в использовании HashMap? |
Потому что хеширование происходит на моменте создании, не надо делать повторного пересчёта

№37 Почему строки не рекомендуется использовать для хранения паролей? |
Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, 
она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, НО объект остается доступным в памяти
некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто-либо, 
имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста. Если мы используем массив символов для хранения пароля, мы можем очистить его
после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности, 
свойственного строке public char [] getPassword() {}

№38 Почему String неизменяемый и финализированный класс? |
Безопасность и String pool – это основные причины неизменяемости String в Java.

№39 Для чего используется оператор assert? |
Assert (утверждение) – это специальная конструкция, позволяющая проверять
предположения о значениях произвольных данных в произвольном месте программы.
Утверждение может подать сигнал об обнаружении некорректных данных и привести к завершению программы с указанием проблемного места.
Утверждения существенно упрощают локализацию ошибок в коде.

№40 Тернарный условный оператор |
условие ? выражение1 : выражение2
Если условие выполняется, то вычисляется выражение1 и его результат становится
результатом выполнения всего оператора.

№41 Когда в приложении может быть выброшено исключение ClassCastException? |
ClassCastException (потомок RuntimeException) – исключение, которое будет выброшено при ошибке приведения типа.

№42 Что делает метод intern() в классе String? |
Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.

№43 Какая основная разница между String, StringBuffer, StringBuilder? |
Класс String является неизменяемым (immutable) – модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.
Класс StringBuffer изменяемый – использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.
Класс StringBuilder он во всем идентичен классу StringBuffer за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей

№44 Что такое StringJoiner? |
Класс StringJoiner используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс

№45 Что такое сигнатура метода? |
Это имя метода плюс параметры.  В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения
Сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми
исключениями называется контрактом метода.
От модификатора до выбрасываемого исключения – это контракт.

№46 Расскажите про метод main |
Является, как правило, точкой входа в программу и вызывается JVM.
Как только заканчивается выполнение метода main(), так сразу же завершается работа
самой программы.
static – чтобы JVM смогла загрузить его во время компиляции.
public static void и сигнатура – обязательное декларирование.
Мэйнов может быть много и может не быть вообще.
Может быть перегружен.

№47 Каким образом переменные передаются в методы, по значению или по ссылке? |
В Java параметры всегда передаются только по значению, что определяется как
«скопировать значение и передать копию»
Массив – это объект

№48 Если передать массив и изменить его в методе, то будет ли изменяться текущий массив? |
Да, текущий массив изменится тоже.

№49 Какие типы классов есть в Java? |
Top level class (обычный класс):
	◦ Abstract class (абстрактный класс);
	◦ Final class (финализированный класс).
• Interfaces (интерфейс).
• Enum (перечисление).
• Nested class (вложенный класс):
	◦ Static nested class (статический вложенный класс);
	◦ Member inner class (простой внутренний класс);
	◦ Local inner class (локальный класс);
	◦ Anonymous inner class (анонимный класс).

№50 Расскажите про вложенные классы. В каких случаях они применяются? |
Если он определен внутри другого класса, то такой класс вложенный
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий
его класс.
Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. 
Вложенные классы делятся на две категории: статические и нестатические. Объявленные вложенные классы static называются статическими вложенными классами. Нестатические вложенные классы называются внутренними классами.
1. Статические вложенные классы (Static nested classes)
• есть возможность обращения к внутренним статическим полям и методам классаобертки;
• обрамляющий класс не имеет доступа к статическим полям;
• из статического вложенного класса не имеем доступ к статическим полям
внешнего класса.
2. Вложенные классы (Non-static Nested)
есть возможность обращения к внутренним полям и методам класса-обертки;
• не может иметь статических объявлений;
• внутри такого класса нельзя объявить перечисления;
• если нужно явно получить this внешнего класса – OuterClass.this.
3. Локальные классы
• видны только в пределах блока, в котором объявлены;
• не могут быть объявлены как private/public/protected или static (по этой причине
интерфейсы нельзя объявить локально);
• не могут иметь внутри себя статических объявлений (полей, методов, классов), но
могут иметь константы (static final);
• имеют доступ к полям и методам обрамляющего класса;
• можно обращаться к локальным переменным и параметрам метода, если они
объявлены с модификатором final или являются effectively final.
4. Анонимные классы
• локальный класс без имени;
• создается, чтобы его сразу же применить.

№51 Что такое «статический класс»? |
Это вложенный класс, объявленный с использованием ключевого слова static. К классам
верхнего уровня модификатор static неприменим.

№52 Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними? |
Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и
приватным.
Для создания объекта статического вложенного класса объект внешнего класса не
требуется
Из объекта статического вложенного класса обращаться к не статическим членам
обрамляющего класса можно только через ссылку на экземпляр внешнего класса.
Обычные вложенные классы не могут содержать статических методов, блоков
инициализации и классов. Статические вложенные классы могут.
В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статического такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляет я через указание .this после его имени. Например: Outer.this

№53 Что такое «локальный класс»? Каковы его особенности? |
Local inner class (локальный класс) – это вложенный класс, который может быть
декларирован в любом блоке, в котором разрешается декларировать переменные.
Локальные классы имеют следующие особенности:
• видны только в пределах блока, в котором объявлены;
• не могут быть объявлены как private/public/protected или static;
• не могут иметь внутри себя статических объявлений (полей, методов, классов);
• имеют доступ к полям и методам обрамляющего класса;
• могут обращаться к локальным переменным и параметрам метода, если они
объявлены с модификатором final.

№54 Что такое «анонимные классы»? Где они применяются? |
Это вложенный локальный класс без имени, который разрешено декларировать в любом
месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра
анонимного класса происходит одновременно с его объявлением.
В зависимости от местоположения ведёт себя как статический или нестатический вложенный класс.
Ограничения:
• использование разрешено только в одном месте программы – месте его создания;
• применение возможно только в том случае, если после порождения экземпляра
нет необходимости на него ссылаться;
• реализует лишь методы своего интерфейса или суперкласса
Применяется для:
• создания объекта функции (Пример Comporator)
• создания объекта процесса (Пример Thread, Runnable)
• в статическом методе генерации;
• инициализации открытого статического поля final, которое соответствует сложному
перечислению типов, когда для каждого экземпляра в перечислении требуется
отдельный подкласс.

№55 Каким образом из вложенного класса получить доступ к полю внешнего класса? |
Статический вложенный класс имеет прямой доступ только к статическим полям
обрамляющего класса.
Простой внутренний класс может обратиться к любому полю внешнего класса напрямую. В
случае, если у вложенного класса уже существует поле с таким же литералом, то
обращаться к такому полю следует через ссылку на его экземпляр. Например: Outer.this.field.

№56 Что такое перечисления (enum)? |
Перечисления представляют набор логически связанных констант.
Нужны для ограничения области допустимых значений: например, времена года, дни
недели.
Перечисление фактически представляет новый класс, поэтому можно определить
переменную данного типа и использовать ее.
Могут опеределять конструкторы поля и методы. Конструктор по дефолту приватный. Также можно определять методы для отдельных констант.
Можно создавать публичные геттеры\сеттеры. Они создаются в момент компиляции
Методы:
• valueOf() возвращает конкретный элемент;
• ordinal() возвращает порядковый номер определенной константы (нумерация
начинается с 0);
• values() возвращает массив всех констант перечисления;
• name() отличается от toString тем, что второй можно переопределить.
Работает == и equals, не работают операторы больше меньше и тд.

№57 Особенности Enum классов? |
• Конструктор всегда private или default.
• Могут имплементировать интерфейсы.
• Не могут наследовать класс.
• Можно переопределить toString().
• Нет public конструктора, поэтому нельзя создать экземпляр вне Enum.
• При equals() выполняется ==.
• ordinal() возвращает порядок элементов.
• Может использоваться в TreeSet и TreeMap, т. к. Enum имплементирует
Comparable.
• compareTo() имитирует порядок элементов, предоставляемый ordinal().
• Можно использовать в Switch Case.
• values() возвращает массив всех констант.
• Легко создать потокобезопасный singleton без double check volatile переменных

№58 Что такое singleton?  |
Паттерн проектирования, который гарантирует, что у класса будет лишь один экземпляр и предоставляет глобальную точку доступа
к этому экземпляру.
Ключевые особенности:
1)Класс имеет приватный конструктор, чтобы предотвратить создание объекта извне.
2) Экземпляр класса хранится как статическая переменная.
3) Публичный метод предоставляет доступ к единственному экземпляру класса.

№59 Double-checked locking с использованием volatile? |
Это техника для создания потокобезопасного синглтона с минимальной задержкой.
Volatile переменная гарантирует, что все потоки будут видеть актуальное значение экземпляра, а не кэшированное.
Double check — это проверка экземпляра дважды: один раз вне синхронизированного блока и один раз внутри. Это минимизирует накладные расходы, связанные с блокировкой.
Блокировка — это механизм, который гарантирует, что в критическую секцию кода одновременно может войти только один поток, предотвращая ошибки доступа к общим ресурсам. Однако, блокировка может замедлить выполнение программы, так как потоки вынуждены ждать.
В случае double-checked locking, блокировка выполняется только при первом создании объекта, а последующие вызовы к объекту выполняются быстрее, так как синхронизация уже не нужна.

№60 Ромбовидное наследование |
В java нет множественного наследования КЛАССОВ, только интерфейсов.
Ромбовидное наследование (англ. diamond inheritance) – ситуация в объектноориентированных языках программирования с поддержкой множественного наследования, 
когда два класса B и C наследуют от A, а класс D наследует от обоих классов B и C.
В java возможно только с помощью интерфейсов и тогда пользователю предоставляется выбор, от какого родителя наследовать.

№61 Дайте определение понятию «конструктор» |
Метод, у которого отсуствует возвращаемый тип. Имеет тоже имя, что и класс. Вызывается при создании нового объекта и определяет действия необходимые для инициализации.

№62 Что такое конструктор по умолчанию? |
Если у какого-либо класса не определить конструктор, то компилятор сгенерирует
конструктор без аргументов – так называемый «конструктор по умолчанию».
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
В классе-наследнике при отсутствии переопределенного конструктора будет использован
конструктор родителя.

№63 Могут ли быть приватные конструкторы? Для чего они нужны? |
Приватный да. Он запрещает создание экземляра класса вне методов самого класса.
Финальный нет.
Нужны для реализации паттернов.
У абстрактного класса есть приватный конструктор (абстрактный класс позволяет описать некоторое состояние объекта)
 
№64 Расскажите про классы-загрузчики и про динамическую загрузку классов |
Bootstrap ClassLoader главный загрузчик (загружает платформенные классы JDK из архива rt.jar);
Extension ClassLoader загрузчик расширений (загружает все необходимые библиотеки из директории java.home)
AppClassLoader системный загрузчик (загружает классы определенные в CLASSPATH)
Цепочка: Загрузка начинается с Bootstrap, затем передаётся Extension, и последним работает Application ClassLoader.
Исключение – ClassNotFoundExtension.
Динамическая загрузка происходит «на лету» в ходе выполнения программы с помощью
статического метода класса Class.forName (имя класса). Например, не знаем, какой класс понадобится и принимаем решение в ходе выполнения программы, передавая имя класса в статический метод forName().

№65 Чем отличаются конструкторы по умолчанию, конструктор копирования и конструктор с параметрами? |
• у конструктора по умолчанию отсутствуют какие-либо аргументы;
• конструктор копирования принимает в качестве аргумента уже существующий
объект класса для последующего создания его клона;
• конструктор с параметрами имеет в своей сигнатуре аргументы (обычно
необходимые для инициализации полей класса).

№66 Какие модификаторы доступа есть в Java? Какие применимы к классам? |
• private (приватный): члены класса доступны только внутри класса. 
• default, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. (По умолчанию)
• protected (защищенный): члены класса доступны внутри пакета и в наследниках. 
• public (публичный): класс/члены класса доступны всем.
Во время наследования возможно изменения модификаторов доступа в сторону большей
видимости. Класс может быть объявлен с модификатором public и default.

№67 Может ли объект получить доступ к члену класса объявленному как private? Если да, то каким образом? |
• внутри класса доступ к приватной переменной открыт без ограничений;
• вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам
содержащего его класса;
• доступ к приватным переменным извне может быть организован через отличные
от приватных методы, которые предоставлены разработчиком класса. Например:
getX() и setX().
• через механизм рефлексии (Reflection API).

№68 Что означает модификатор static? |
Статическая переменная – это переменная, принадлежащая классу, а не объекту.
Статический класс – это вложенный класс, который может обращаться только к статическим полям обертывающего его класса.
Внутри статического метода нельзя вызвать нестатический метод по имени класса. Можно
обратиться к статическому методу через экземпляр класса.
Статик применим к полям, методам, вложенным классам, членам секции import, блокам инициализации.

№69 В чем разница между членом экземпляра класса и статическим членом класса? |
Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. 
Ограничения:
• могут вызывать только другие статические методы;
• должны осуществлять доступ только к статическим переменным;
• не могут ссылаться на члены типа this или super.

№70 Может ли статический метод быть переопределен или перегружен? |
Перегружен – да. Всё работает так же как и с обычными методами
Переопределён - нет.

№71 Могут ли нестатические методы перегрузить статические? |
Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет
доступен через его имя, а нестатический будет принадлежать конкретному объекту и
доступен через вызов метода этого объекта

№72 Как получить доступ к переопределенным методам родительского класса? |
С помощью ключевого слова super мы можем обратиться к любому члену родительского
класса – методу или полю, если они не определены с модификатором private.
super.method();

№73 Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода? |
При переопределении метода нельзя сузить модификатор доступа к методу (например, с
public до private), но можно расширить.
Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое
значение, если они совместимы. Например, если метод возвращает объект класса, а
переопределенный метод возвращает класс-наследник.

№74 Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т. п.)? |
При переопределении метода сужать модификатор доступа не разрешается, т. к. это
приведет к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа
возможно.
Можно изменять все, что не мешает компилятору понять, какой метод родительского класса
имеется в виду:
Поэтому в сигнатуре (имя + параметры) менять ничего нельзя, но возможно расширение
уровня доступа
Изменять тип возвращаемого значения при переопределении метода разрешено только в
сторону сужения типа (вместо родительского класса-наследника).
Секцию throws метода можно не указывать, но стоит помнить, что она остается
действительной, если уже определена у метода родительского класса. 

№75 Могут ли классы быть статическими? |
Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class)

№76 Что означает модификатор final? К чему он может быть применим? |
Модификатор final может применяться к переменным, параметрам методов, полям и
методам класса или самим классам.
• класс не может иметь наследников;
• метод не может быть переопределен в классах-наследниках;
• поле не может изменить свое значение после инициализации;
• параметры методов не могут изменять свое значение внутри метода;
• для локальных переменных примитивного типа это означает, что однажды
присвоенное значение не может быть изменено;
• для ссылочных переменных это означает, что после присвоения объекта нельзя
изменить ссылку на данный объект (ссылку изменить нельзя, но состояние
объекта изменять можно).
 Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.
к. это взаимоисключающие понятия.

№ 77 Что такое абстрактные классы? Чем они отличаются от обычных? |
Это обычный класс, но с абстрактными методами.
Особенности абстрактных классов:
• может быть конструктор (удобен для паттерна декоратор, для вызовов по цепочке
из наследников);
• может содержать абстрактные методы и обычные методы;
• может создать приватный конструктор, но нужен тогда еще один, чтобы можно
было его расширять;
• имплементят интерфейсы, но не обязаны реализовывать их методы;
• не может быть final, так как наследниками абстрактного класса могут быть
другие абстрактные классы;
• могут быть статические методы (т. к. помимо наследования и переопределения
абстрактный класс может использоваться без наследования);
• нельзя создать объект или экземпляр абстрактного класса;
• абстрактные методы могут отсутствовать;
• меняет хотя бы один абстрактный метод;
• абстрактный метод не может быть вне абстрактного класса;
• может содержать метод main().

№ 78 Где и для чего используется модификатор abstract? |
Класс, помеченный модификатором abstract, называется абстрактным классом. Такие
классы могут выступать только предками для других классов. Создавать экземпляры самого
абстрактного класса не разрешается. При этом наследниками абстрактного класса могут
быть как другие абстрактные классы, так и классы, допускающие создание объектов.
Метод, помеченный ключевым словом abstract, – абстрактный метод, т. е. метод, который не
имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь
класс должен быть объявлен абстрактным.
Использование абстрактных классов и методов позволяет описать некий шаблон объекта,
который должен быть реализован в других классах. В них же самих описывается лишь некое
общее для всех потомков поведение.

№79 Можно ли объявить метод абстрактным и статическим одновременно? |
Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: ‘abstract’ and
‘static’"

№80 Может ли быть абстрактный класс без абстрактных методов? |
Класс может быть абстрактным без единого абстрактного метода, если у него указан
модификатор abstract.

№81 Могут ли быть конструкторы у абстрактных классов? Для чего они нужны? |
Да. Необходимы для наследников. Если конструктор не объявлен, то компилятор добавит конструктор по умолчанию.

№82 Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов? |
Интерфейс – это совокупность методов, определяющих правила взаимодействия
элементов системы. Другими словами, интерфейс определяет как элементы будут
взаимодействовать между собой. 
Ключевое слово interface используется для создания полностью абстрактных классов. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы
неявно объявляются как public.
Интерфейс также может содержать и поля. В этом случае они автоматически являются
публичными public, статическими static и неизменяемыми final.
• методы интерфейса являются публичными (public) и абстрактными (abstract),
если имплементироть интерфейс, то наследующий его класс должен будет
реализовать все эти абстрактные методы, в отличии от абстрактного класса;
• поля – public static final;
• есть дефолтный метод;
• нужно обязательно прописывать static;
• методы могут быть static.

№83 Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс? |
1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у
него нет (кроме public static final), в то время как у абстрактного класса они могут быть.
2. Можно наследовать только один класс, а реализовать интерфейсов сколько угодно.
Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
3. Абстрактные классы используются, когда есть отношение «is-a», то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
4. Нет конструктора у интерфейса.
Абстрактный класс – средство, позволяющее избежать написания повторяющегося кода,
инструмент для частичной реализации поведения.
Интерфейс – это средство выражения семантики класса, контракт, описывающий
возможности.
Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя
интерфейс, он расширяет собственную функциональность.


№84 Что имеет более высокий уровень абстракции – класс, абстрактный класс или интерфейс? |
Интерфейс.

№85 Может ли один интерфейс наследоваться от другого? От двух других? |
Да, может. Используется ключевое слово extends.

№86 Что такое дефолтные методы интерфейсов? Для чего они нужны? |
Интерфейсы могут иметь их реализацию по умолчанию,
которая используется, если класс, реализующий данный интерфейс, не реализует метод.
Это нужно для обратной совместимости.

№87 Почему в некоторых интерфейсах вообще не определяют методов? |
Это так называемые маркерные интерфейсы. Они просто указывают, что класс относится к
определенному типу. Примером может послужить интерфейс Clonable, который указывает
на то, что класс поддерживает механизм клонирования.

№88 Что такое static метод интерфейса? |
Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что
для них отсутствует возможность переопределения в классах, реализующих интерфейс.
Статические методы в интерфейсе используются для обеспечения вспомогательных
методов, например, проверки на null, сортировки коллекций и т. д

№89 Как вызывать static метод интерфейса? |
Используя имя интерфейса:
Paper.show();

№90 Почему нельзя объявить метод интерфейса с модификатором final? |
В случае интерфейсов указание модификатора final бессмысленно, т. к. все методы
интерфейсов неявно объявляются как абстрактные, т. е. их невозможно выполнить, не
реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор final.

№91 Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default-методов? |
Обязательным переопределением default-метода.

№92 Каков порядок вызова конструкторов инициализации с учетом иерархии классов? |
Сначала вызываются все статические блоки в очередности от первого статического блока
корневого предка и выше по цепочке иерархии до статических блоков самого класса.
Затем вызываются нестатические блоки инициализации корневого предка, конструктор
корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.
При создании объекта производного класса конструкторы вызываются в порядке вниз по
иерархии наследования классов, т. е. начиная с самого базового класса и заканчивая
производным классом.

№93 Зачем нужны и какие бывают блоки инициализации? |
Блоки инициализации представляют собой код, заключенный в фигурные скобки и
размещаемый внутри класса вне объявления методов или конструкторов.
Существуют статические и нестатические блоки инициализации.
Статические - используются для выполнения кода, который должен выполняться один раз при
инициализации класса.
Нестатические - когда объект класса создаётся при помощи конструктора.

№94 Для чего используются статические блоки инициализации? |
Статические блоки инициализация используются для выполнения кода, который должен
выполняться один раз при инициализации класса загрузчиком классов в момент,
предшествующий созданию объектов этого класса при помощи конструктора. Такой блок
принадлежит только самому классу.

№95 Где разрешена инициализация статических/нестатических полей? |
Статические поля можно инициализировать при объявлении, в статическом или
нестатическом блоке инициализации.
Нестатические поля можно инициализировать при объявлении, в нестатическом блоке
инициализации или в конструкторе.

№96 Что произойдет, если в блоке инициализации возникнет исключительная ситуация? |
Для нестатических блоков инициализации, если выбрасывание исключения прописано
явным образом, требуется, чтобы объявления этих исключений были перечислены в throws
всех конструкторов класса (в контракте конструктора). Иначе будет ошибка компиляции.
В остальных случаях взаимодействие с исключениями будет проходить так же, как и в
любом другом месте. Класс не будет инициализирован, если ошибка происходит в
статическом блоке, и объект класса не будет создан, если ошибка возникает в
нестатическом блоке
Для статического блока выбрасывание исключения в явном виде приводит к ошибке
компиляции ExceptionInizialazionError.

№97 Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса? |
Если возникшее исключение – наследник RuntimeException:
• для статических блоков инициализации будет выброшено
java.lang.ExceptionInInitializerError;
• для нестатических будет проброшено исключение-источник
Если возникшее исключение – наследник Error, то в обоих случаях будет выброшено
java.lang.Error.
Если исключение java.lang.ThreadDeath (смерть потока), то в этом случае никакое
исключение выброшено не будет.

№98 Что такое класс Object? |
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В
результате объект Object может ссылаться на объект любого другого класса.

№99 Какие методы есть у класса Object (перечислить все)? Что они делают? |
Object – это базовый класс для всех остальных объектов в Java. Любой класс наследуется от
Object и, соответственно, наследуют его методы:
• public boolean equals(Object obj) – служит для сравнения объектов по значению;
• int hashCode() – возвращает hash-код для объекта;
• String toString() – возвращает строковое представление объекта;
• Class getClass() – возвращает класс объекта во время выполнения;
• protected Object clone() – создает и возвращает копию объекта;
• void notify() – возобновляет поток, ожидающий монитор;
• void notifyAll() – возобновляет все потоки, ожидающие монитор;
• void wait() – остановка вызвавшего метод потока до момента, пока другой поток
не вызовет метод notify() или notifyAll() для этого объекта;
• void wait(long timeout) – остановка вызвавшего метод потока на определенное
время или пока другой поток не вызовет метод notify() или notifyAll() для этого
объекта;
• void wait(long timeout, int nanos) – остановка вызвавшего метод потока на
определенное время или пока другой поток не вызовет метод notify() или notifyAll()
для этого объекта;
• protected void finalize() – может вызываться сборщиком мусора в момент
удаления объекта при сборке мусора.

№100 Расскажите про equals и hashcode |
Хеш-код – это целочисленный результат работы метода, которому в качестве входного
параметра передан объект. Рассчитывается по нативному методу.
Equals – это метод, определенный в Object, который служит для сравнения объектов. При
сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по
equals() идет сравнение по состояниям объектов (по умолчанию случайным образом, но
есть другие варианты).
По умолчанию ссылки, чтобы его использовать, нужно переопределить (на область в
памяти), т. к. при == сравниваются ссылки, а equals сравнивает состояния:

№101 Свойства equals() |
• Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
• Симметричность: для любых ссылок на значения x и y, x.equals(y) должно
вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
• Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и
y.equals(z) возвращают true, тогда и x.equals(z) вернет true;
• Непротиворечивость: для любых ссылок на значения х и у, если несколько раз
вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно
будет возвращаться значение false при условии, что никакая информация,
используемая при сравнении объектов, не поменялась;
• Совместимость с hashCode(): два тождественно равных объекта должны иметь
одно и то же значение hashCode().
При переопределении equals() обязательно нужно переопределить метод hashCode().
Равные объекты должны возвращать одинаковые хэш коды.

№102 Каким образом реализованы методы hashCode() и equals() в классе Object? |
1. Реализация метода Object.equals() сводится к проверке на равенство двух ссылок
2. Реализация метода Object.hashCode() описана как native, т. е. определенной не с
помощью Java-кода и обычно возвращает адрес объекта в памяти

№103 Зачем нужен equals(). Чем он отличается от операции ==? |
Метод equals() определяет отношение эквивалентности объектов.
При сравнение объектов с помощью == сравнение происходит лишь между ссылками.
При сравнении по переопределенному разработчиком equals() – по внутреннему состоянию
объектов.

№104 Правила переопределения метода Object.equals() |
• Использование оператора == для проверки, является ли аргумент ссылкой на
указанный объект. Если является, возвращается true. Если сравниваемый объект
== null, должно вернуться false
• Использование оператора instanceof и вызова метода getClass() для проверки,
имеет ли аргумент правильный тип. Если не имеет, возвращается false.
• Приведение аргумента к правильному типу. Поскольку эта операция следует за
проверкой instanceof она гарантированно будет выполнена.
• Обход всех значимых полей класса и проверка того, что значение поля в текущем
объекте и значение того же поля в проверяемом на эквивалентность аргументе
соответствуют друг другу. Если проверки для всех полей прошли успешно,
возвращается результат true, в противном случае – false.
• По окончанию переопределения метода equals() следует проверить: является ли
порождаемое отношение эквивалентности рефлексивным, симметричным,
транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит
соответствующей правке

№105 Что будет, если переопределить equals(), не переопределяя hashCode()? Какие могут возникнуть проблемы? |
Классы и методы, которые используют правила этого контракта, могут работать некорректно.
Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в нее
помещена, при использовании нового экземпляра ключа не будет в ней найдена.

№106 Какой контракт между hashCode() и equals()? |
1. Если два объекта возвращают разные значения hashcode(), то они не могут быть
равны.
2. Если equals объектов true, то и хеш-коды должны быть равны.
3. Переопределив equals, всегда переопределять и hashcode.

№107 Для чего нужен метод hashCode()? |
Метод hashCode() необходим для вычисления хеш-кода переданного в качестве входного
параметра объекта.
• если хеш-коды разные, то и объекты гарантированно разные;
• если хеш-коды равны, то объекты могут не обязательно равны.
Значение int может быть в диапазоне 232, при переопределении хеш-кода можно
использовать отрицательное значение

№108 Правила переопределения метода hashcode() |
1. Если хеш-коды разные, то и входные объекты гарантированно разные.
2. Если хеш-коды равны, то входные объекты не всегда равны.
3. При вычислении хеш-кода следует использовать те же поля, которые сравниваются в
equals и которые не вычисляются на основе других значений.

№109 Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()? |
Следует выбирать поля, которые с большой долью вероятности будут различаться. Для
этого необходимо использовать уникальные, лучше всего примитивные поля, например
такие как id, uuid. При этом нужно следовать правилу: если поля задействованы при
вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

№110 Могут ли у разных объектов быть одинаковые hashCode()? |
Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения.
Ситуация, когда у разных объектов одинаковые хеш-коды называется коллизией.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хешкода.

№111 Почему нельзя реализовать hashcode(), который будет гарантированно уникальным для каждого объекта? |
В Java множество возможных хеш-кодов ограничено типом int, а множество объектов ничем
не ограничено.
Из-за этого вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.

№112 Почему хеш-код в виде 31 * x + y предпочтительнее чем x + y? |
• множитель создает зависимость значения хеш-кода от очередности обработки
полей, что в итоге порождает лучшую хеш-функцию;
• 31 можно легко сдвигать побитово;
• в хеш-коде должны фигурировать поля, которые фигурируют в equals().

№113 Чем a.getClass().equals(A.class) отличается от a instanceOf A.class? |
getClass() получает только класс, а оператор instanceof проверяет, является ли объект
экземпляром класса или его потомком.

№114 instanceof |
Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для
проверки, является ли данный объект экземпляром некоторого класса, либо экземпляром
его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.

№115 Что такое исключение? |
Исключение – это ошибка (является объектом), возникающая во время выполнения
программы.

№116 Опишите иерархию исключений |
Исключения делятся на несколько классов, но все они имеют общего предка – класс
Throwable, потомками которого являются классы Exception и Error.
		      Object
		     Throwable C
Error: UC
ThreadDeath  UC
VirtualMachineError(OutOfMemory, StackOverflow) UC
IOError UC

Exception: C
RuntimeException UC

IOException C
SQLException C
BrokenBarrierException C

Отдельно:
NullPointerExeption UC
ArithmeticException UC

Исключения делятся на несколько классов, но все они имеют общего предка – класс
Throwable, потомками которого являются классы Exception и Error.

№117 Расскажите про обрабатываемые и необрабатываемые исключения |
В Java все исключения делятся на два типа:
• checked (контролируемые/проверяемые исключения) должны обрабатываться
блоком catch или описываться в сигнатуре метода (например throws IOException),
наличие такого обработчика/модификатора сигнатуры проверяются на этапе
компиляции;
• unchecked (неконтролируемые/непроверяемые исключения), к которым относятся
ошибки Error (например OutOfMemoryError), обрабатывать которые не
рекомендуется и исключения времени выполнения, представленные классом
RuntimeException и его наследниками (например NullPointerException), которые
могут не обрабатываться блоком catch и не быть описанными в сигнатуре метода.

№118 Можно ли обработать необрабатываемые исключения? |
Можно, чтобы в некоторых случаях программа не прекратила работу. Отлавливаются в trycatch.

№119 Какой оператор позволяет принудительно выбросить исключение? |
Это оператор throw:
throw new Exception();

№120 О чем говорит ключевое слово throws? |
Модификатор throws прописывается в сигнатуре метода и указывает на то, что метод
потенциально может выбросить исключение с указанным типом.
Передает обработку исключения вышестоящему методу. Используется в конструкторе,
методе, классе.

№121 Как написать собственное («пользовательское») исключение? |
Необходимо унаследоваться от базового класса требуемого типа исключений (например, от
Exception или RuntimeException) и переопределить методы.

№122 Какие существуют unchecked exception? |
Наиболее часто встречающиеся: ArithmeticException, ClassCastException,
ConcurrentModificationException, IllegalArgumentException, IllegalStateException,
IndexOutOfBoundsException, NoSuchElementException, NullPointerException,
UnsupportedOperationException.

№123 Что представляет из себя ошибки класса Error? |
Ошибки класса Error представляют собой наиболее серьезные проблемы уровня JVM.
Например, исключения такого рода возникают, если закончилась память, доступная
виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не
рекомендуется.

№124 Что вы знаете о OutOfMemoryError? |
OutOfMemoryError выбрасывается, когда виртуальная машина Java не может создать
(разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить
достаточное ее количество.
java.lang.OutOfMemoryError: Java heap space: не хватает места в куче
java.lang.OutOfMemoryError: GC overhead limit exceeded памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места
java.lang.OutOfMemoryError: unable to create new native thread: Выбрасывается,
когда нет возможности создавать новые потоки

№125 Опишите работу блока try-catch-finally |
try – данное ключевое слово используется для отметки начала блока кода, который
потенциально может привести к ошибке.
catch – ключевое слово для отметки начала блока кода, предназначенного для перехвата и
обработки исключений в случае их возникновения.
finally – ключевое слово для отметки начала блока кода, который является дополнительным.
Этот блок помещается после последнего блока catch. Управление передается в блок finally в
любом случае, было выброшено исключение или нет.

№126 Возможно ли использование блока try-finally (без catch)? |
Такая запись допустима, но смысла в такой записи не так много, все же лучше иметь блок
catch, в котором будет обрабатываться необходимое исключение.
Работает точно так же: после выхода из блока try выполняется блок finally.

№127 Может ли один блок catch отлавливать сразу несколько исключений? |
Да catch(IOException | SQLException ex) {

№128 Всегда ли исполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен? |
Да, кроме случаев завершения работы программы или JVM:
• Finally может не выполниться в случае если в блоке try вызывает System.exit(0).
• Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время
исполнения блока try виртуальная машина выполнила недопустимую операцию и
будет закрыта.
• В блоке try{} бесконечный цикл

№129 Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения? |
Может, исключение будет передано в виртуальную машину Java (JVM).

№130 В каком порядке следует обрабатывать исключения в catch-блоках? |
От наследника к предку

№131 Что такое механизм try-with-resources |
Механизм, позволяющий автоматически закрывать потоки после использования. Неявно вызывается finally компилятором.
Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются
ресурсы в неявном finally.
Используется автоматически интерфейс Closeble

№132 Что произойдет, если исключение будет выброшено из блока catch, после чего другое исключение будет выброшено из блока finally? |
finally-секция может «перебить» throw/return при помощи другого throw/return.

№133 Что произойдет, если исключение будет выброшено из блока catch, после чего другое исключение будет выброшено из метода close() при использовании try-with-resources? |
В try-with-resources добавлена возможность хранения «подавленных» исключений, и
брошенное try-блоком исключение имеет больший приоритет, чем исключения,
получившиеся во время закрытия

№134 Предположим, есть метод, который может выбросить IOException и FileNotFoundException. В какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено? |
Общее правило: обрабатывать исключения нужно от младшего к старшему. Т. е. нельзя
поставить в первый блок catch(Exception ex) {}, иначе все дальнейшие блоки catch() уже
ничего не смогут обработать, т. к. любое исключение будет соответствовать обработчику
catch(Exception ex).

№135 Что такое «сериализация» и как она реализована в Java? |
Сериализация (Serialization) – процесс преобразования структуры данных в линейную
последовательность байтов для дальнейшей передачи или сохранения. Сериализованные
объекты можно затем восстановить (десериализовать).
Есть два стандартных способа: стандартная сериализация через использование интерфейса
java.io.Serializable и «расширенная» сериализация – java.io.Externalizable.
Сериализация позволяет в определенных пределах изменять класс. Вот наиболее важные
изменения, с которыми спецификация Java Object Serialization может справляться
автоматически:
• добавление в класс новых полей;
• изменение полей из статических в нестатические;
• изменение полей из транзитных в нетранзитные.

№136 Для чего нужна сериализация? |
Для компактного сохранения состояния объекта и считывание этого состояния.

№137 Опишите процесс сериализации/десериализации с использованием Serializable |
При использовании Serializable применяется алгоритм сериализации, который с помощью
рефлексии (Reflection API) выполняет:
• запись в поток метаданных о классе, ассоциированном с объектом (имя класса,
идентификатор SerialVersionUID, идентификаторы полей класса);
• рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не
включительно);
• запись примитивных значений полей сериализуемого экземпляра, начиная с
полей самого верхнего суперкласса;
• рекурсивную запись объектов, которые являются полями сериализуемого объекта.
При этом ранее сериализованные объекты повторно не сериализуются, что позволяет
алгоритму корректно работать с циклическими ссылками.
Для выполнения десериализации под объект выделяется память, после чего его поля
заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако
при десериализации будет вызван конструктор без параметров родительского
несериализуемого класса, а его отсутствие повлечет ошибку десериализации.

№138 Как изменить стандартное поведение сериализации/десериализации? |
Реализовать интерфейс java.io.Externalizable, который позволяет применение
пользовательской логики сериализации. Способ сериализации и десериализации
описывается в методах writeExternal() и readExternal(). Во время десериализации вызывается
конструктор без параметров, а потом уже на созданном объекте вызывается метод
readExternal.
Если у сериализуемого объекта реализован один из следующих методов, то механизм
сериализации будет использовать его, а не метод по умолчанию :
• writeObject() – запись объекта в поток;
• readObject() – чтение объекта из потока;
• writeReplace() – позволяет заменить себя экземпляром другого класса перед
записью;
• readResolve() – позволяет заменить на себя другой объект после чтения.

№139 Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final-поле? |
Поля с модификатором transient. В таком случае после восстановления его значение будет null.
Поля static. Значения статических полей автоматически не сохраняются.
Поля с модификатором final сериализуются как и обычные. За одним исключением – их
невозможно десериализовать при использовании Externalizable. Поможет только Serializable
Если final-поля не кастомные, то будут десериализовываться.

№140 Как создать собственный протокол сериализации? |
Для создания собственного протокола нужно переопределить writeExternal() и
readExternal().

№141 Какая роль поля serialVersionUID в сериализации? |
serialVersionUID используется для указании версии сериализованных данных
Если не указать явно, среда выполнения Java сделает это самостоятельно

№142 Когда стоит изменять значение поля serialVersionUID? |
serialVersionUID нужно изменять при внесении в класс несовместимых изменений, например,
при удалении какого-либо его атрибута.

№143 В чем проблема сериализации Singleton? |
Проблема в том, что после десериализации получим другой объект. Таким образом,
сериализация дает возможность создать Singleton еще раз, что недопустимо.
Существует два способа избежать этого:
• явный запрет сериализации;
• определение метода с сигнатурой (default/public/private/protected/) Object
readResolve() throws ObjectStreamException, назначением которого станет возврат
замещающего объекта вместо объекта, на котором он вызван.

№144 Как исключить поля из сериализации? |
Для управления сериализацией при определении полей можно использовать ключевое
слово transient, таким образом исключив поля из общего процесса сериализации.

№145 Что обозначает ключевое слово transient? |
Поля класса, помеченные модификатором transient, не сериализуются

№146 Какое влияние оказывают на сериализуемость модификаторы полей static и final? |
При стандартной сериализации поля, имеющие модификатор static, не сериализуются.
Поля с модификатором final сериализуются как и обычные. За одним исключением – их
невозможно десериализовать при использовании Externalizable

№147 Как не допустить сериализацию? |
Чтобы не допустить автоматическую сериализацию, можно переопределить private методы
для создания исключительной ситуации NotSerializableException.

№148 Какие существуют способы контроля за значениями десериализованного объекта? |
Если есть необходимость выполнения контроля за значениями десериализованного объекта,
то можно использовать интерфейс ObjectInputValidation с переопределением метода
validateObject().
Также существуют способы подписывания и шифрования, позволяющие убедиться, что
данные не были изменены:
• с помощью описания логики в writeObject() и readObject();
• поместить в оберточный класс javax.crypto.SealedObject и/или
java.security.SignedObject.

№149 Расскажите про клонирование объектов |
Для создания нового объекта с таким же состоянием используется клонирование объекта.
Класс Object содержит protected метод clone(), осуществляющий побитовое копирование
объекта производного класса. Однако сначала необходимо переопределить метод clone()
как public для обеспечения возможности его вызова. В переопределенном методе следует
вызвать базовую версию метода super.clone(), которая и выполняет собственно
клонирование. Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс
Cloneable.
Помимо встроенного механизма клонирования в Java для клонирования объекта можно
использовать:
• специализированный конструктор копирования – в классе описывается
конструктор, который принимает объект этого же класса и инициализирует поля
создаваемого объекта значениями полей переданного;
• фабричный метод – (factory method), который представляет собой статический
метод, возвращающий экземпляр своего класса;
• механизм сериализации – сохранение и последующее восстановление объекта
в/из потока байтов.

№150 В чем отличие между поверхностным и глубоким клонированием? |
Поверхностное копирование копирует настолько малую часть информации об объекте,
насколько это возможно. По умолчанию клонирование в Java является поверхностным
Глубокое копирование дублирует абсолютно всю информацию объекта.

№151 Какой способ клонирования предпочтительней? |
Наиболее безопасным и следовательно предпочтительным способом клонирования
является использование специализированного конструктора копирования
• отсутствие ошибок наследования (не нужно беспокоиться, что у наследников
появятся новые поля, которые не будут склонированы через метод clone();
• поля для клонирования указываются явно;
• возможность клонировать даже final-поля.

№152 Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable? |
Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить
доступ к стандартному механизму поверхностного копирования объектов. 

№153 Как создать глубокую копию объекта (2 способа)? |
Глубокое клонирование требует выполнения следующих правил:
• нет необходимости копировать отдельно примитивные данные;
• все классы-члены в оригинальном классе должны поддерживать клонирование,
Для каждого члена класса должен вызываться super.clone() при переопределении
метода clone();
• если какой-либо член класса не поддерживает клонирование, то в методе
клонирования необходимо создать новый экземпляр этого класса и скопировать
каждый его член со всеми атрибутами в новый объект класса, по одному.
Сериализация – это еще один способ глубокого копирования. Просто сериализуем нужный
объект и десериализуем его. При этом объект должен поддерживать интерфейс Serializable.
Сохраняем объект в массив байт и потом читаем из него.

№154 Рефлексия |
Рефлексия (Reflection) – это механизм получения данных о программе во время ее
выполнения (runtime).
• определение класса объекта;
• получение информации о модификаторах класса, полях, методах, конструкторах и
суперклассах;
• определение интерфейсов, реализуемых классом;
• создание экземпляра класса;
• получение и установка значений полей объекта;
• вызов методов объекта;
• создание нового массива.

№155 Класс Optional |
Опциональное значение Optional – это контейнер для объекта, который может содержать
или не содержать значение null. Такая обертка является удобным средством
предотвращения NullPointerException






