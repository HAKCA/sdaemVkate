№1 Что такое процесс? |
Процесс – экземпляр программы во время выполнения, независимый объект,
которому выделены системные ресурсы.
Каждый процесс выполняется в отдельном адресном пространстве: один процесс не
может получить доступ к переменным и структурам данных другого

№2 Что такое поток? |
Поток (thread) – способ выполнения процесса, определяющий последовательность
исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо
процесса, и вся их жизнь проходит только в его границах.
Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а
также совместно использовать описатели объектов ядра, поскольку таблица описателей
создается не в отдельных потоках, а в процессах. Выгоднее создавать дополнительные потоки,
так как они расходуют существенно меньше ресурсов.

№3 Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? |
Thread – это класс, некоторая надстройка над физическим потоком.
Runnable – это интерфейс, представляющий абстракцию над выполняемой задачей.
Runnable помогает разрешить проблему множественного наследования, позволяет
отделить логику выполнения задачи от непосредственного управления потоком.
Реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс.
Создавать подкласс, порожденный от класса Thread, следует только в том случае, 
если нужно дополнить его новыми функциями.

№4 Что такое монитор? Как монитор реализован в java? |
Монитор – механизм синхронизации потоков, обеспечивающий доступ к неразделяемым
ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у
каждого объекта.
Удобно представлять mutex как id захватившего его объекта. Если id равен 0 – ресурс
свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.
В Java монитор реализован с помощью ключевого слова synchronized.

№5 Что такое синхронизация? |
Синхронизация – это процесс, который позволяет выполнять потоки параллельно.
В Java все объекты имеют блокировку, только один поток одновременно
может получить доступ к критическому коду в объекте. Синхронизация помогает
предотвратить повреждение состояния объекта.

№6 Способы синхронизации в Java. |
1. Системная синхронизация с использованием wait()/notify().
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(),
предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток
может вызвать на этом же самом объекте метод notify(), предварительно захватив монитор
объекта, в результате чего ждущий на объекте поток «просыпается» и продолжает свое
выполнение. В обоих случаях монитор надо захватывать в явном виде через synchronized-блок, 
потому как методы wait()/notify() не синхронизированы!

2. Системная синхронизация с использованием join().
Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку
остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.

3. Использование классов из пакета java.util.concurrent.Locks – механизмы
синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock,
Condition, ReadWriteLock

№7 Как работают методы wait(), notify() и notifyAll()? |
• wait(): освобождает монитор и переводит вызывающий поток в состояние
ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();
• notify(): продолжает работу потока, у которого ранее был вызван метод wait();
• notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait()
wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.

№8 В каких состояниях может находиться поток? |
New – объект класса Thread создан, но еще не запущен. Он еще не является потоком
выполнения и естественно не выполняется.
Runnable – поток готов к выполнению, но планировщик еще не выбрал его.
Running – поток выполняется.
Waiting/blocked/sleeping – поток блокирован или ждет окончания работы другого потока.
Dead – поток завершен. Будет выброшено исключение при попытке вызвать метод start() для
потока dead.

№9 Что такое семафор? Как он реализован в Java? |
Semaphore – это новый тип синхронизатора: семафор со счетчиком, реализующий
шаблон синхронизации «Семафор». Доступ управляется с помощью счетчика:
изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда
поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда
поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток
блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется
для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например,
подключение к базе данных в пуле.

№10 Что означает ключевое слово volatile? Почему операции над volatile переменными не атомарны? |
Переменная volatile является атомарной для чтения, но операции над переменной НЕ
являются атомарными. Поля, для которых неприемлемо увидеть «несвежее» (stale)
значение в результате кеширования или переупорядочения.
Если происходит какая-то операция, например, инкримент, то атомарность уже не
обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в
локальной памяти, а затем запись(3). Такая операция не является атомарной и в нее может
вклиниться поток по середине.
Атомарная операция выглядит единой и неделимой командой процессора.
Переменная volatile находится в хипе, а не в кеше стека.

№11 Для чего нужны типы данных atomic? Чем отличаются от volatile? |
volatile не гарантирует атомарность.
class AtomicInteger предоставляет атомарный метод для выполнения комплексных операций атомарно

№12 Что такое потоки демоны? Для чего они нужны? Как создать поток-демон? |
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются
неотъемлемой частью программы.
Если какой-либо процесс может выполняться на фоне работы основных потоков
выполнения и его деятельность заключается в обслуживании основных потоков
приложения, то запускаем с помощью метода setDaemon(boolean value), 
вызванного у потока до его запуска.
Основной поток приложения может завершить выполнение потока-демона (в
отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания,
что поток-демон еще работает.
Поток демон можно сделать, только если он еще не запущен.
Пример демона – сборщик мусора (GC)

№13 Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию? |
Приоритеты потоков используются планировщиком потоков для принятия решений о том,
когда и какому из потоков будет разрешено работать. Теоретически высокоприоритетные
потоки получают больше времени процессора, чем низкоприоритетные.
Чтобы установить приоритет потока, используется метод класса Thread: final void
setPriority(int level) от 1 до 10, по умолчанию - 5. getPriority - узнать приоритет.
Метод yield() можно использовать для того, чтобы принудить планировщик выполнить
другой поток, который ожидает своей очереди.

№14 Как работает Thread.join()? Для чего он нужен? |
Когда поток вызывает join(), он будет ждать, пока поток, к которому он присоединяется, будет
завершен либо отработает переданное время:
void join()
void join(long millis) – с временем ожидания
void join(long millis, int nanos)
Применение: при распараллеливании вычисления, надо дождаться результатов, чтобы
собрать их в кучу и продолжить выполнение.

№15 Чем отличаются методы wait() и sleep()? |
Метод sleep() приостанавливает поток на указанное время. Состояние меняется на
WAITING, по истечении – RUNNABLE. Монитор не освобождается.
Метод wait() меняет состояние потока на WAITING. Может быть вызван только у объекта,
владеющего блокировкой, в противном случае выкинется исключение
IllegalMonitorStateException.

№16 Можно ли вызвать start() для одного потока дважды? |
Нельзя стартовать поток больше одного раза. Поток не может быть перезапущен, если он
уже завершил выполнение.

№17 Как правильно остановить поток? Для чего нужны методы stop(),interrupt(),interrupted(),isInterrupted()? |
1. Для корректной остановки потока можно использовать метод класса Thread interrupt().
Этот метод выставляет внутренний флаг-статус прерывания. В дальнейшем состояние этого
флага можно проверить с помощью метода isInterrupted() или Thread.interrupted()
2. Второй вариант реализации метода остановки (а также и приостановки) – сделать
собственный аналог interrupt(). Т. е. объявить в классе потока флаги на остановку и/или
приостановку и выставлять их путем вызова заранее определенных методов извне.

№18 Почему не рекомендуется использовать метод Thread.stop()? |
При принудительной остановке (приостановке) потока stop() прерывает поток в
недетерменированном месте выполнения, в результате становится совершенно
непонятно, что делать с принадлежащими ему ресурсами.

№19 В чем разница между interrupted() и isInterrupted()? |
Когда прерванный поток проверяет статус прерывания, вызывая статический метод
Thread.interrupted(), статус прерывания сбрасывается.
Нестатический метод isInterrupted() используется одним потоком для проверки статуса
прерывания у другого потока, не изменяя флаг прерывания.

№20 Чем Runnable отличается от Callable? |
1. Runnable появился раньше Cannable;
2. Классы у Runnable реализовывают метод run(), у Cannable call();
3. Метод Runnable.run() не возвращает никакого значения;
4. Callable – это параметризованный функциональный интерфейс, Callable.call()
возвращает Object, если он не параметризован, иначе указанный тип;
5. метод run() НЕ может выбрасывать проверяемые исключения, в то время как
метод call() может

№21 Что такое FutureTask? |
Этот класс предоставляет базовую реализацию Future с методами для запуска и
остановки вычисления, методами для запроса состояния вычисления и извлечения
результатов
Результат может быть получен, только когда вычисление завершено, метод получения
будет заблокирован, если вычисление еще не завершено.
Объекты FutureTask могут быть использованы для обертки объектов Callable и Runnable. Так
как FutureTask помимо Future реализует Runnable, его можно передать в Executor на
выполнение.

№22 Что такое deadlock? |
Взаимная блокировка (deadlock) – явление, при котором все потоки находятся в режиме
ожидания и свое состояние не меняют. Происходит, когда достигаются состояния:
• взаимного исключения: по крайней мере один ресурс занят в режиме неделимости,
и следовательно только один поток может использовать ресурс в данный момент
времени;
• удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает
дополнительные ресурсы, которые удерживаются другими потоками;
• отсутствия предочистки: операционная система не переназначает ресурсы – если
они уже заняты, то должны отдаваться удерживающим потокам сразу же;
• цикличного ожидания: поток ждет освобождения ресурса другим потоком, который в
свою очередь ждет освобождения ресурса заблокированного первым потоком.
Простейший способ избежать взаимной блокировки – не допускать цикличного
ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в
определенном порядке и освобождая их в обратном порядке.

№23 Что такое livelock? |
livelock – тип взаимной блокировки, при котором несколько потоков выполняют
бесполезную работу, попадая в зацикленность при попытке получения каких-либо
ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга.
Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в
результате попыток предотвращения deadlock
Примеры livelock:
• 2 человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит
в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не
продвигаясь в нужном им направлении;
• аналогично 2 пылесоса в узком коридоре пытаются выяснить, кто должен первым
убрать один и тот же участок;
• на равнозначном перекрестке 4 автомобиля не могут определить, кто из них должен
уступить дорогу;
• одновременный звонок друг другу.


№24 Что такое race condition? |
– ошибка проектирования многопоточной системы или
приложения, при которой работа зависит от того, в каком порядке выполняются
потоки. Состояние гонки возникает, когда поток, который должен исполниться в начале,
проиграл гонку, и первым исполняется другой поток: поведение кода изменяется, из-за
чего возникают недетерменированные ошибки.
Starvation – потоки не заблокированы, но есть нехватка ресурсов, из-за чего потоки ничего
не делают.
DataRace - выполнение программы считается
содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа
(чтение или запись в одну и ту же переменную), которые не упорядочены отношениями
«happens before».

№25 Что такое Фреймворк fork/join? Для чего он нужен? |
Это набор классов и интерфейсов,
позволяющих использовать преимущества многопроцессорной архитектуры современных
компьютеров. Он разработан для выполнения задач, которые можно рекурсивно
разбить на маленькие подзадачи, которые можно решать параллельно.
Этап Fork: большая задача разделяется на несколько меньших подзадач
Этап Join: далее (опционально) идет процесс «свертки» – решения подзадач некоторым
образом объединяются, пока не получится решение всей задачи
Еще одно преимущество этого фреймворка заключается в том, что он использует workstealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут
«украсть» подзадачи у других потоков, которые все еще заняты.

№26 Что означает ключевое слово synchronized? Где и для чего может использоваться? |
Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах
или блоках кода.

№27 Что является монитором у статического synchronized-метода? |
Объект типа Class, соответствующий классу, в котором определен метод.

№28 Что является монитором у нестатического synchronized-метода? |
Объект this.

№29 util.Concurrent поверхностно |
Классы и интерфейсы пакета java.util.concurrent объединены в несколько групп по
функциональному признаку:
collections – набор эффективно работающих в многопоточной среде коллекций
CopyOnWriteArrayList(Set), ConcurrentHashMap.

№30 Stream API & ForkJoinPool, как связаны, что это такое? |
В Stream API есть простой способ распараллеливания потока методом parallel() или
parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах.
По умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается
статически и живет пока не будет вызван System::exit. Если задачам не указывать
конкретный пул, то они будут исполняться в рамках commonPool.

№31 Java Memory Model |
Описывает как потоки должны взаимодействовать через общую память. Определяет
набор действий межпоточного взаимодействия. В частности, чтение и запись переменной,
захват и освобождение монитора, чтение и запись volatile переменной, запуск нового потока.